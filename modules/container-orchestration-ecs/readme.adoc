= Digital Modernization

== Container Orchestration

****
*Expected Outcome:*

* 200 level usage of Amazon ECS/Fargate

*Lab Requirements:*

* an Amazon Elastic Container Service Cluster

*Average Lab Time:*
30-45 minutes
****

=== Introduction

In this module, we're going to deploy applications using http://aws.amazon.com/ecs/[Amazon Elastic Container Service (Amazon ECS)] to orchestrate our containers on top of http://aws.amazon.com/fargate/[AWS Fargate].

==== Getting Started with Amazon ECS using AWS Fargate

Before we get started, here are some definitions you need to understand in order to deploy your application when creating your first Amazon ECS cluster.

[options="header"]
|=======================
| Object | Cluster
| Cluster | Logical grouping of tasks and services. Infrastructure may be shared between tasks and services running on the same cluster.
| Task Definition | Blueprint for our application. Defines attributes such as CPU and memory requirements, networking configuration, and container definitions.
| Container Definition | Configuration for a container to run as part of our task. Defines attributes of the container including port mappings, resources requirements, environment variables, etc.
| Service | Maintains a specified number of running simultaneous instances of a task definition in an ECS cluster.
|=======================

You'll deploy a service via Amazon ECS using AWS Fargate as the launch type. The Fargate launch type allows you to run your containerized applications without the need to provision and manage the back-end infrastructure. Amazon ECS also can launch tasks and services using the EC2 launch type which runs containerized applications on Amazon EC2 instances that you manage. Amazon ECS is the orchestration service responsible for running docker containers and AWS Fargate is the underlying compute platform where the containers will run.

===== Deploy our VPC

We will first deploy our CloudFormation template which configures our ECS VPC.

Step 1:: Change to this modules directory by running:
+
[source,shell]
----
cd ~/environment/aws-modernization-workshop/modules/container-orchestration-ecs
----
+
Step 2:: Deploy the CloudFormation template to create your new VPC
+
[source,shell]
----
aws cloudformation create-stack \
  --stack-name "petstore" \
  --template-body file://petstore-fargate-cf-resources.yaml \
  --capabilities CAPABILITY_NAMED_IAM
----
+
Step 3:: Wait for the Template to finish deploying
+
[source,shell]
----
until [[ `aws cloudformation describe-stacks --stack-name "petstore" --query "Stacks[0].[StackStatus]" --output text` == "CREATE_COMPLETE" ]]; do  echo "The stack is NOT in a state of CREATE_COMPLETE at `date`";   sleep 30; done && echo "The Stack is built at `date` - Please proceed"
----

===== Amazon ECS Task definitions

https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definitions.html[Amazon ECS Task definitions] are required to run Docker containers in Amazon ECS.
For our pestore application, we will review the key pieces of a task definition before we deploy it.

Step 1:: Open the *petstore-fargate-task-definition.json* file in your favorite text editor.
+
The file has the following content:
+
.petstore-fargate-task-definition.json
[.output]
....
{
  "family": "petstore",
  "networkMode": "awsvpc",
  "containerDefinitions": [{
      "name": "postgres",
      "image": "<YourAccountID>.dkr.ecr.us-west-2.amazonaws.com/petstore_postgres:latest",
      "cpu": 512,
      "memoryReservation": 1024,
      "environment": [{
          "name": "POSTGRES_DB",
          "value": "petstore"
        },
        {
          "name": "POSTGRES_USER",
          "value": "admin"
        },
        {
          "name": "POSTGRES_PASSWORD",
          "value": "password"
        }
      ],
      "portMappings": [{
        "containerPort": 5432
      }],
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "petstore",
          "awslogs-region": "us-west-2",
          "awslogs-stream-prefix": "petstore/postgres"
        }
      }
    },
    {
      "name": "petstore",
      "image": "<YourAccountID>.dkr.ecr.us-west-2.amazonaws.com/petstore_frontend:latest",
      "cpu": 512,
      "memoryReservation": 1024,
      "environment": [
        {
          "name": "DB_HOST",
          "value": "127.0.0.1"
        },
        {
          "name": "DB_NAME",
          "value": "petstore"
        },
        {
          "name": "DB_PASS",
          "value": "password"
        },
        {
          "name": "DB_PORT",
          "value": "5432"
        },
        {
          "name": "DB_URL",
          "value": "jdbc:postgresql://127.0.0.1:5432/petstore?ApplicationName=applicationPetstore"
        },
        {
          "name": "DB_USER",
          "value": "admin"
        }
      ],
      "portMappings": [{
        "containerPort": 8080
      }],
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "petstore",
          "awslogs-region": "us-west-2",
          "awslogs-stream-prefix": "petstore/frontend"
        }
      }
    }
  ],
  "executionRoleArn": "arn:aws:iam::<YourAccountID>:role/petstoreExecutionRole",
  "requiresCompatibilities": [
    "FARGATE"
  ],
  "cpu": "1 vcpu",
  "memory": "2 gb"
}
....
+
Step 2:: We need to replace the placeholder for your account id in the template file, so that is aware of your account. The below shell script does that for you automatically using the `sed` and `aws` cli tools.
+
[source,shell]
----
ACCOUNT_ID=$(aws ecr describe-repositories --repository-name petstore_frontend --query=repositories[0].repositoryUri --output=text | cut -d"." -f1)
echo ${ACCOUNT_ID}
sed -i "s/<YourAccountID>/${ACCOUNT_ID}/" ~/environment/aws-modernization-workshop/modules/container-orchestration-ecs/petstore-fargate-task-definition.json
----
+
Step 3:: Create a new task definition from the JSON file by running this command
+
[source,shell]
----
aws ecs register-task-definition --cli-input-json file://~/environment/aws-modernization-workshop/modules/container-orchestration-ecs/petstore-fargate-task-definition.json
----

===== Create the Petstore Service with Amazon ECS using Fargate

Step 1:: Go to the AWS Management Console, click Services then select *ECS* under Compute.
+
Step 2:: On the left hand navigation ensure *Clusters* is selected and click *Create Cluster*.
+
Step 3:: On the *Select cluster template* screen select *Networking only* which should have a *Powered by AWS Fargate* label and click *Next step*.
+
Step 4:: Enter a Cluster name of *petstore-workshop* and leave the Create VPC box *unchecked* and click *Create*.
+
Step 5:: Once your cluster is created, view your cluster and the *Services* tab should be selected. Click *Create*.
+
Step 6:: Select a *Launch type* of *FARGATE*
+
Step 7:: Select *petstore* and the latest *revision* for the *Task Definition*.
+
Step 8:: Enter *petstore* for the *Service name*.
+
Step 9:: Enter *1* into *Number of tasks* and click *Next step*.
+
Step 10:: Select the *petstore* VPC for *Cluster VPC*.
+
Step 11:: Select the two *Public* petstore Subnets for *Subnets*.
+
Step 12:: For *Security Groups* click *Edit* then click *Select an existing Security Group*. Select the *default* Security Group and click Save. You will notice that the default Security Group only allows port 8080 from PetStoreLbSecurityGroup to secure our petstore application.
+
Step 13:: Select *ENABLED* from *Auto-assign public IP*. This allows your tasks to retrieve the Docker image from Amazon ECR and stream logs to Amazon CloudWatch Logs.
+
Step 14:: Under Load Balancing, select the Application Load Balancer and make sure *petstore-lb* is selected.
+
Step 15:: Set the *Health check grace period* to *300*. Note: This is the period of time, in seconds, that the Amazon ECS service scheduler should ignore unhealthy Elastic Load Balancing target health checks after a task has first started. This is only valid if your service is configured to use a load balancer. If your service's tasks take a while to start and respond to health checks, you can specify a health check grace period of up to 7,200 seconds during which the ECS service scheduler ignores the health check status. This grace period can prevent the ECS service scheduler from marking tasks as unhealthy and stopping them before they have time to come up.
+
Step 16:: For *Container to load balance* select *petstore:8080:8080* and click *Add to load balancer*.
+
Step 17:: Type in `80` for the *Listener port* and ensure it is set to *create new*.
+
Step 18:: Ensure that *Target group name* is set to *create new* and the name should be *ecs-petsto-petstore*.
+
Step 19:: *Uncheck* the box for *Enable service discovery integration* and click *Next step*.
+
Step 20:: The next page allows you to define an Auto Scaling policy. Leave this set to *Do not adjust the service's desired count* for now and click *Next step*.
+
Step 21:: Review your settings and click *Create Service*.
+
Step 22:: The service will now start your task. Click *View Service* and you will have to wait for your task to transition to *RUNNING*. Feel free to inspect the logs for your task while you wait.
+
Step 23:: Once the task is running, view the *Details* of the petstore *Service*. Under *Load Balancing* click the *ecs-petsto-petstore* Target Group link to view
the Tasks being registered into the Target Group under *Targets*.
+
Step 24:: Once your Registered Target is registered as *Healthy* you can view the service through the Application Load Balancer.
+
Step 25:: Get the URL for your running application
+
[source,shell]
----
printf "http://%s\n" $(aws elbv2 describe-load-balancers --names="petstore-lb" --query="LoadBalancers[0].DNSName" --output=text)
----
+
Step 26:: Open the URL output above in your Browser.

Now that we have a Fargate cluster, with a Service using our application deployed we can move on with the workshop.
